/*!
<https://github.com/grpc/grpc-go/tree/master/internal/resolver>
*/

use std::{
    task::Context,
    sync
};

use crate::{
    internal::service_config::MethodConfig,
    metadata,
    resolver::State
};

// ConfigSelector controls what configuration to use for every RPC.
pub trait ConfigSelector {
    // Selects the configuration for the RPC, or terminates it using the error.
    // This error will be converted by the gRPC library to a status error with
    // code UNKNOWN if it is not returned as a status error.
    fn select_config(RPCInfo) (*RPCConfig, error)
}

// RPCInfo contains RPC information needed by a ConfigSelector.
pub struct RPCInfo {
    // Context is the user's context for the RPC and contains headers and
    // application timeout.  It is passed for interception purposes and for
    // efficiency reasons.  select_config should not be blocking.
    pub Context Context,
    pub Method: String // i.e. "/Service/Method"
}

// RPCConfig describes the configuration to use for each RPC.
pub struct RPCConfig {
    // The context to use for the remainder of the RPC; can pass info to LB
    // policy or affect timeout or metadata.
    Context      Context,
    MethodConfig serviceconfig.MethodConfig // configuration to use for this RPC
    OnCommitted  func()                     // Called when the RPC has been committed (retries no longer possible)
    Interceptor  ClientInterceptor
}

// ClientStream is the same as grpc.ClientStream, but defined here for circular
// dependency reasons.
pub trait ClientStream {
    // Header returns the header metadata received from the server if there
    // is any. It blocks if the metadata is not ready to read.
    fn Header() (metadata.MD, error)
    // Trailer returns the trailer metadata from the server, if there is any.
    // It must only be called after stream.CloseAndRecv has returned, or
    // stream.Recv has returned a non-nil error (including io.EOF).
    fn Trailer() metadata.MD
    // CloseSend closes the send direction of the stream. It closes the stream
    // when non-nil error is met. It is also not safe to call CloseSend
    // concurrently with SendMsg.
    fn CloseSend() error
    // Context returns the context for this stream.
    //
    // It should not be called until after Header or RecvMsg has returned. Once
    // called, subsequent client-side retries are disabled.
    fn Context() Context
    // SendMsg is generally called by generated code. On error, SendMsg aborts
    // the stream. If the error was generated by the client, the status is
    // returned directly; otherwise, io.EOF is returned and the status of
    // the stream may be discovered using RecvMsg.
    //
    // SendMsg blocks until:
    //   - There is sufficient flow control to schedule m with the transport, or
    //   - The stream is done, or
    //   - The stream breaks.
    //
    // SendMsg does not wait until the message is received by the server. An
    // untimely stream closure may result in lost messages. To ensure delivery,
    // users should ensure the RPC completed successfully using RecvMsg.
    //
    // It is safe to have a goroutine calling SendMsg and another goroutine
    // calling RecvMsg on the same stream at the same time, but it is not safe
    // to call SendMsg on the same stream in different goroutines. It is also
    // not safe to call CloseSend concurrently with SendMsg.
    fn SendMsg(m interface{}) error
    // RecvMsg blocks until it receives a message into m or the stream is
    // done. It returns io.EOF when the stream completes successfully. On
    // any other error, the stream is aborted and the error contains the RPC
    // status.
    //
    // It is safe to have a goroutine calling SendMsg and another goroutine
    // calling RecvMsg on the same stream at the same time, but it is not
    // safe to call RecvMsg on the same stream in different goroutines.
    fn RecvMsg(m interface{}) error
}

// ClientInterceptor is an interceptor for gRPC client streams.
pub trait ClientInterceptor {
    // NewStream produces a ClientStream for an RPC which may optionally use
    // the provided function to produce a stream for delegation.  Note:
    // RPCInfo.Context should not be used (will be nil).
    //
    // done is invoked when the RPC is finished using its connection, or could
    // not be assigned a connection.  RPC operations may still occur on
    // ClientStream after done is called, since the interceptor is invoked by
    // application-layer operations.  done must never be nil when called.
    fn NewStream(ctx Context, ri RPCInfo, done func(), newStream func(ctx Context, done func()) (ClientStream, error)) (ClientStream, error)
}

// ServerInterceptor is an interceptor for incoming RPC's on gRPC server side.
pub trait ServerInterceptor {
    // AllowRPC checks if an incoming RPC is allowed to proceed based on
    // information about connection RPC was received on, and HTTP Headers. This
    // information will be piped into context.
    fn AllowRPC(ctx Context) error // TODO: Make this a real interceptor for filters such as rate limiting.
}

type csKeyType string

const csKey = csKeyType("grpc.internal.resolver.configSelector")

// SetConfigSelector sets the config selector in state and returns the new
// state.
pub fn SetConfigSelector(state: State, cs: ConfigSelector) -> State {
    state.Attributes = state.Attributes.WithValue(csKey, cs)
    return state
}

// GetConfigSelector retrieves the config selector from state, if present, and
// returns it or nil if absent.
pub fn GetConfigSelector(state: State) -> ConfigSelector {
    cs, _ := state.Attributes.Value(csKey).(ConfigSelector)
    return cs
}

// SafeConfigSelector allows for safe switching of ConfigSelector
// implementations such that previous values are guaranteed to not be in use
// when update_config_selector returns.
pub struct SafeConfigSelector {
    mu sync.RWMutex,
    cs: ConfigSelector
}

// update_config_selector swaps to the provided ConfigSelector and blocks until
// all uses of the previous ConfigSelector have completed.
pub fn (scs *SafeConfigSelector) update_config_selector(cs: ConfigSelector) {
    scs.mu.Lock()
    defer scs.mu.Unlock()
    scs.cs = cs
}

// select_config defers to the current ConfigSelector in scs.
pub fn (scs *SafeConfigSelector) select_config(r: RPCInfo) (*RPCConfig, error) {
    scs.mu.RLock()
    defer scs.mu.RUnlock()
    return scs.cs.select_config(r)
}
