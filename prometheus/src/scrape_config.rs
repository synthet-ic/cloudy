/*!
<https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config>
*/

use std::{
    collections::HashMap,
    path::PathBuf,
    time::Duration,
};

use serde::{Serialize, Deserialize};

use crate::{
    authorisation::Authorisation,
    basic_auth::BasicAuth,
    oauth2::OAuth2,
    tls_config::TLSConfig,
};

#[skip_serializing_none]
#[derive(Debug, Serialize, Deserialize)]
pub struct ScrapeConfig {
    /// The job name assigned to scraped metrics by default.
    job_name: <job_name>,

    /// How frequently to scrape targets from this job.
    #[serde(default = "global_config.scrape_interval")]
    scrape_interval: Option<Duration>,

    /// Per-scrape timeout when scraping this job.
    #[serde(default = "global_config.scrape_timeout")]
    scrape_timeout: Option<Duration>,

    /// The HTTP resource path on which to fetch metrics from targets.
    #[serde(default = "/metrics")]
    metrics_path: Option<PathBuf>,

    /**
    honor_labels controls how Prometheus handles conflicts between labels that are
    already present in scraped data and labels that Prometheus would attach
    server-side ("job" and "instance" labels, manually configured target
    labels, and labels generated by service discovery implementations).

    If honor_labels is set to "true", label conflicts are resolved by keeping label
    values from the scraped data and ignoring the conflicting server-side labels.

    If honor_labels is set to "false", label conflicts are resolved by renaming
    conflicting labels in the scraped data to "exported_<original-label>" (for
    example "exported_instance", "exported_job") and then attaching server-side
    labels.

    Setting honor_labels to "true" is useful for use cases such as federation and
    scraping the Pushgateway, where all labels specified in the target should be
    preserved.

    Note that any globally configured "external_labels" are unaffected by this
    setting. In communication with external systems, they are always applied only
    when a time series does not have a given label yet and are ignored otherwise.
    */
    #[serde(default = "false")]
    honor_labels: Option<bool>,

    /**
    honor_timestamps controls whether Prometheus respects the timestamps present
    in scraped data.

    If honor_timestamps is set to "true", the timestamps of the metrics exposed
    by the target will be used.

    If honor_timestamps is set to "false", the timestamps of the metrics exposed
    by the target will be ignored.
    */
    #[serde(default = "true")]
    honor_timestamps: Option<bool>,

    /// Configures the protocol scheme used for requests.
    #[serde(default = "http")]
    scheme: Option<Scheme>,

    /// Optional HTTP URL parameters.
    params: Option<HashMap<String, Vec<String>>>,

    /**
    Sets the `Authorization` header on every scrape request with the
    configured username and password.
    password and password_file are mutually exclusive.
    */
    basic_auth: Option<BasicAuth>,

    /**
    Sets the `Authorization` header on every scrape request with
    the configured credentials.
    */
    #[serde(rename(serialize = "authorization"))]
    authorisation: Option<Authorisation>,

    /// Optional OAuth 2.0 configuration.
    /// Cannot be used at the same time as basic_auth or authorization.
    oauth2: Option<OAuth2>,

    /// Configure whether scrape requests follow HTTP 3xx redirects.
    #[serde(default = "true")]
    follow_redirects: Option<bool>,

    /// Whether to enable HTTP2.
    #[serde(default = "true")]
    enable_http2: Option<bool>,

    /// Configures the scrape request's TLS settings.
    tls_config: Option<TLSConfig>,

    /// Optional proxy URL.
    proxy_url: Option<String>,

    /// List of Azure service discovery configurations.
    azure_sd_configs: Option<Vec<azure_sd_config>>,

    /// List of Consul service discovery configurations.
    consul_sd_configs: Option<Vec<consul_sd_config>>,

    /// List of DigitalOcean service discovery configurations.
    digitalocean_sd_configs: Option<Vec<digitalocean_sd_config>>,

    /// List of Docker service discovery configurations.
    docker_sd_configs: Option<Vec<docker_sd_config>>,

    /// List of Docker Swarm service discovery configurations.
    dockerswarm_sd_configs: Option<Vec<dockerswarm_sd_config>>,

    /// List of DNS service discovery configurations.
    dns_sd_configs: Option<Vec<dns_sd_config>>,

    /// List of EC2 service discovery configurations.
    ec2_sd_configs: Option<Vec<ec2_sd_config>>,

    /// List of Eureka service discovery configurations.
    eureka_sd_configs: Option<Vec<eureka_sd_config>>,

    /// List of file service discovery configurations.
    file_sd_configs: Option<Vec<file_sd_config>>,

    /// List of GCE service discovery configurations.
    gce_sd_configs: Option<Vec<gce_sd_config>>,

    /// List of Hetzner service discovery configurations.
    hetzner_sd_configs: Option<Vec<hetzner_sd_config>>,

    /// List of HTTP service discovery configurations.
    http_sd_configs: Option<Vec<http_sd_config>>,

    /// List of IONOS service discovery configurations.
    ionos_sd_configs: Option<Vec<ionos_sd_config>>,

    /// List of Kubernetes service discovery configurations.
    kubernetes_sd_configs: Option<Vec<kubernetes_sd_config>>,

    /// List of Kuma service discovery configurations.
    kuma_sd_configs: Option<Vec<kuma_sd_config>>,

    /// List of Lightsail service discovery configurations.
    lightsail_sd_configs: Option<Vec<lightsail_sd_config>>,

    /// List of Linode service discovery configurations.
    linode_sd_configs: Option<Vec<linode_sd_config>>,

    /// List of Marathon service discovery configurations.
    marathon_sd_configs: Option<Vec<marathon_sd_config>>,

    /// List of AirBnB's Nerve service discovery configurations.
    nerve_sd_configs: Option<Vec<nerve_sd_config>>,

    /// List of Nomad service discovery configurations.
    nomad_sd_configs: Option<Vec<nomad_sd_config>>,

    /// List of OpenStack service discovery configurations.
    openstack_sd_configs: Option<Vec<openstack_sd_config>>,

    /// List of PuppetDB service discovery configurations.
    puppetdb_sd_configs: Option<Vec<puppetdb_sd_config>>,

    /// List of Scaleway service discovery configurations.
    scaleway_sd_configs: Option<Vec<scaleway_sd_config>>,

    /// List of Zookeeper Serverset service discovery configurations.
    serverset_sd_configs: Option<Vec<serverset_sd_config>>,

    /// List of Triton service discovery configurations.
    triton_sd_configs: Option<Vec<triton_sd_config>>,

    /// List of Uyuni service discovery configurations.
    uyuni_sd_configs: Option<Vec<uyuni_sd_config>>,

    /// List of labeled statically configured targets for this job.
    static_configs: Option<Vec<static_config>>,

    /// List of target relabel configurations.
    relabel_configs: Option<Vec<relabel_config>>,

    /// List of metric relabel configurations.
    metric_relabel_configs: Option<Vec<relabel_config>>,

    /**
    An uncompressed response body larger than this many bytes will cause the
    scrape to fail. 0 means no limit. Example: 100MB.
    This is an experimental feature, this behaviour could
    change or be removed in the future.
    */
    #[serde(default = "0")]
    body_size_limit: Option<Size>,
    /**
    Per-scrape limit on number of scraped samples that will be accepted.
    If more than this number of samples are present after metric relabeling
    the entire scrape will be treated as failed. 0 means no limit.
    */
    #[serde(default = "0")]
    sample_limit: Option<i32>,

    /**
    Per-scrape limit on number of labels that will be accepted for a sample. If
    more than this number of labels are present post metric-relabeling, the
    entire scrape will be treated as failed. 0 means no limit.
    */
    #[serde(default = "0")]
    label_limit: Option<i32>,

    /**
    Per-scrape limit on length of labels name that will be accepted for a sample.
    If a label name is longer than this number post metric-relabeling, the entire
    scrape will be treated as failed. 0 means no limit.
    */
    #[serde(default = "0")]
    label_name_length_limit: Option<i32>,

    /**
    Per-scrape limit on length of labels value that will be accepted for a sample.
    If a label value is longer than this number post metric-relabeling, the
    entire scrape will be treated as failed. 0 means no limit.
    */
    #[serde(default = "0")]
    label_value_length_limit: Option<i32>,

    /**
    Per-scrape config limit on number of unique targets that will be
    accepted. If more than this number of targets are present after target
    relabeling, Prometheus will mark the targets as failed without scraping them.
    0 means no limit. This is an experimental feature, this behaviour could
    change in the future.
    */
    #[serde(default = "0")]
    target_limit: Option<i32>,
}
